# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: общее время выполнения программы.
Перед внесением изменений в программу было измерено время выполнения программы для тестовых файлов
Файл с 1000 строками обработался за 0.08 секунды
Файл с 10000 строками обработался за 4.5 секунды
Файл с 20000 строками обработался за 21 секунду
Файл с 3250940 строками обработается как минимум за 1 час, а скорее всего еще больше.
Соотвественно можно сделать вывод, что с ростом размера файла растет и время обработки по более, чем линейной прогрессии.

Бюджет метрики - обработать полный файл минимум за 5 минут.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *время, которое у вас получилось*

Вот как я построил `feedback_loop`:
- проверить время обработки данных
- настроить и провести профилирование
- модифицировать код
- проверить тесты
- замерить результаты выполнения

## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался:
- ruby-prof в режиме Flat

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- Первое замерение ruby-prof в режиме Flat, время выполнения программы до оптимизации 4.5 секунды
- этот отчет показал долю 85.09 в общем времени выполнения программы на метод Array#select
- проблема метода: метод select выполняется над массивом sessions для каждого элемента массива users, соответственно, чем больше users и sessions, тем дольше будет выполняться этот метод
- улучшение метода: 1 раз сгруппировать массив sessions на основе user_id, а затем брать заранее подготовленные данные
- время выполнения программы снизилось до 0.67 секунды
- тесты не показали ошибок
- как изменился отчёт профилировщика:
  - метод select больше не присутствует в отчете
  - метод group_by используется 1 раз и занимает 0.005 секунды на выполнение (42 место среди методов)
  - основной точкой роста стал метод Array#each
