# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она работала слишком долго, и не было понятно, закончит ли она вообще работу за какое-то разумное время.

Я решил исправить эту проблему, оптимизировав эту программу.

## Формирование метрики
Для того, чтобы понимать, дают ли мои изменения положительный эффект на быстродействие программы я придумал использовать такую метрику: время выполнения скрипта
я проверил скорость выполнения скрипта на объеме 1250, 2500, 5000, 10000, 20000 строк с помощью теста для оценки асимпотики
и выяснил что скорость выполнения скрипта степенная, так же написал тест который зафиксировал результат для 5000 тысяч строк, он был равен Total: 1.023775 секунд


## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.

## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за *время, которое у вас получилось*

Вот как я построил `feedback_loop`: 

я написал тест для 5000 тысяч строк с фиксированным временем выполнения и после каждого изменения кода проверял стал ли скрипт работать быстрее


## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался *инструментами, которыми вы воспользовались*

Я основном я использовал ruby-prof и kcachegrind для просмотра отчетов

Вот какие проблемы удалось найти и решить

### Ваша находка №1
- общее время выполнения скрипта для 5000тыс строк Total: 1.023775
- прогнал скрипт через rubocop-performance
- Метрика не сильно изменилась Total: 1.016771
  Отчет ruby-prof не изменился

### Ваша находка №2
- ruby-prof показал что метод select занимает 80.59% времени выполнения
- Я решил группировать сессии по юзеру а не искать искать их в цикле внутри цикла для users
- Скрипт ускорился на 80.50% и составил Total: 0.199639
- Отчет профилировщика изменился и проблема с select перестала быть главной точкой роста

### Ваша находка 3
- ruby-prof показал что метод all? занимает 33.01% времени выполнения и общее время Total: 0.201161
- я пробежал по все коллекции sessions и передавая блок в метод uniq отсек все неуникальные браузеры
- скрипт ускорился на 31.75% и составил Total: 0.137448
- Отчет профилировщика изменился и проблема с all? перестала быть главной точкой роста


### Ваша находка 4
- ruby-prof показал что метод each занимает 32.81% времени выполнения и общее время Total: 0.134507
- я убрал повторные вызовы метода collect_stats_from_users
- скрипт ускорился на 6.64% и составил Total: 0.125575
- Отчет профилировщика не изменился и проблема с each все еще является главной точкой роста


### Ваша находка 5
- ruby-prof показал что метод each занимает 27.92% времени выполнения и общее время Total: 0.134507
- я уменьшил количество лишних вызовов map внутри метода collect_stats_from_users и прогнал обычным рубокопом
- скрипт ускорился на 17.37% и составил Total: 0.111139
- Отчет профилировщика не изменился и проблема с each все еще является главной точкой роста

### Ваша находка 6
- ruby-prof показал что метод each занимает 29.84% времени выполнения и общее время Total: 0.109269
- я уменьшил количество лишних вызовов map внутри метода collect_stats_from_users и прогнал обычным рубокопом
- скрипт ускорился на 17.37% и составил Total: 0.111139
- Отчет профилировщика не изменился и проблема с each все еще является главной точкой роста

### Ваша находка 7
- ruby-prof показал что метод each занимает 30.44% времени выполнения и общее время Total: 0.111139
- я обрал парсинг даты так как после проверки сэмпла оказалось что там дата уже в нужном формате
- скрипт ускорился на 35.28% и составил Total: 0.071929
- Отчет профилировщика не изменился и проблема с each все еще является главной точкой роста

### Ваша находка 8
- ruby-prof показал что метод each занимает 46.62% времени выполнения и общее время Total: 0.072754
- я убрал повторяющийся метод split
- скрипт ускорился на 9.13%% и составил Total: 0.066110
- Отчет профилировщика не изменился и проблема с each все еще является главной точкой роста


### Ваша находка 9
- ruby-prof показал что метод each занимает 46.62% времени выполнения и общее время Total: 0.066110
- я переписал весь скрипт что бы сбор данных шел прямо в цикле чтения файла
- скрипт ускорился на 12.82% и составил Total: 0.057638
- Отчет профилировщика изменился и проблема с each перестала быть главной точкой роста

## Результаты
В результате проделанной оптимизации наконец удалось обработать файл с данными.
Удалось улучшить метрику системы с 1.023775 до 0.057638 и уложиться в заданный бюджет.
data_large.txt стал обрабатываться меньше чем за 30 секунд

Алгоритм обработки сменился со степенного до линейного

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы были написаны тесты производительности

